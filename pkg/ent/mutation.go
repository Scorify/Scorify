// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/scorify/scorify/pkg/ent/audit"
	"github.com/scorify/scorify/pkg/ent/check"
	"github.com/scorify/scorify/pkg/ent/checkconfig"
	"github.com/scorify/scorify/pkg/ent/inject"
	"github.com/scorify/scorify/pkg/ent/injectsubmission"
	"github.com/scorify/scorify/pkg/ent/minion"
	"github.com/scorify/scorify/pkg/ent/predicate"
	"github.com/scorify/scorify/pkg/ent/round"
	"github.com/scorify/scorify/pkg/ent/scorecache"
	"github.com/scorify/scorify/pkg/ent/status"
	"github.com/scorify/scorify/pkg/ent/user"
	"github.com/scorify/scorify/pkg/structs"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAudit            = "Audit"
	TypeCheck            = "Check"
	TypeCheckConfig      = "CheckConfig"
	TypeInject           = "Inject"
	TypeInjectSubmission = "InjectSubmission"
	TypeMinion           = "Minion"
	TypeRound            = "Round"
	TypeScoreCache       = "ScoreCache"
	TypeStatus           = "Status"
	TypeUser             = "User"
)

// AuditMutation represents an operation that mutates the Audit nodes in the graph.
type AuditMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	action        *audit.Action
	ip            **structs.Inet
	timestamp     *time.Time
	message       *string
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Audit, error)
	predicates    []predicate.Audit
}

var _ ent.Mutation = (*AuditMutation)(nil)

// auditOption allows management of the mutation configuration using functional options.
type auditOption func(*AuditMutation)

// newAuditMutation creates new mutation for the Audit entity.
func newAuditMutation(c config, op Op, opts ...auditOption) *AuditMutation {
	m := &AuditMutation{
		config:        c,
		op:            op,
		typ:           TypeAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditID sets the ID field of the mutation.
func withAuditID(id uuid.UUID) auditOption {
	return func(m *AuditMutation) {
		var (
			err   error
			once  sync.Once
			value *Audit
		)
		m.oldValue = func(ctx context.Context) (*Audit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Audit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAudit sets the old Audit of the mutation.
func withAudit(node *Audit) auditOption {
	return func(m *AuditMutation) {
		m.oldValue = func(context.Context) (*Audit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Audit entities.
func (m *AuditMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Audit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *AuditMutation) SetAction(a audit.Action) {
	m.action = &a
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditMutation) Action() (r audit.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldAction(ctx context.Context) (v audit.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditMutation) ResetAction() {
	m.action = nil
}

// SetIP sets the "ip" field.
func (m *AuditMutation) SetIP(s *structs.Inet) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AuditMutation) IP() (r *structs.Inet, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldIP(ctx context.Context) (v *structs.Inet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AuditMutation) ResetIP() {
	m.ip = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *AuditMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AuditMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AuditMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetMessage sets the "message" field.
func (m *AuditMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AuditMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AuditMutation) ResetMessage() {
	m.message = nil
}

// SetUserID sets the "user_id" field.
func (m *AuditMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Audit entity.
// If the Audit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[audit.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[audit.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, audit.FieldUserID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuditMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[audit.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuditMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuditMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuditMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuditMutation builder.
func (m *AuditMutation) Where(ps ...predicate.Audit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Audit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Audit).
func (m *AuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.action != nil {
		fields = append(fields, audit.FieldAction)
	}
	if m.ip != nil {
		fields = append(fields, audit.FieldIP)
	}
	if m.timestamp != nil {
		fields = append(fields, audit.FieldTimestamp)
	}
	if m.message != nil {
		fields = append(fields, audit.FieldMessage)
	}
	if m.user != nil {
		fields = append(fields, audit.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audit.FieldAction:
		return m.Action()
	case audit.FieldIP:
		return m.IP()
	case audit.FieldTimestamp:
		return m.Timestamp()
	case audit.FieldMessage:
		return m.Message()
	case audit.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audit.FieldAction:
		return m.OldAction(ctx)
	case audit.FieldIP:
		return m.OldIP(ctx)
	case audit.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case audit.FieldMessage:
		return m.OldMessage(ctx)
	case audit.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Audit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audit.FieldAction:
		v, ok := value.(audit.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case audit.FieldIP:
		v, ok := value.(*structs.Inet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case audit.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case audit.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case audit.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Audit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Audit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(audit.FieldUserID) {
		fields = append(fields, audit.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditMutation) ClearField(name string) error {
	switch name {
	case audit.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Audit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditMutation) ResetField(name string) error {
	switch name {
	case audit.FieldAction:
		m.ResetAction()
		return nil
	case audit.FieldIP:
		m.ResetIP()
		return nil
	case audit.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case audit.FieldMessage:
		m.ResetMessage()
		return nil
	case audit.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Audit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, audit.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case audit.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, audit.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditMutation) EdgeCleared(name string) bool {
	switch name {
	case audit.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditMutation) ClearEdge(name string) error {
	switch name {
	case audit.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Audit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditMutation) ResetEdge(name string) error {
	switch name {
	case audit.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Audit edge %s", name)
}

// CheckMutation represents an operation that mutates the Check nodes in the graph.
type CheckMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	source                *string
	weight                *int
	addweight             *int
	_config               *map[string]interface{}
	editable_fields       *[]string
	appendeditable_fields []string
	clearedFields         map[string]struct{}
	configs               map[uuid.UUID]struct{}
	removedconfigs        map[uuid.UUID]struct{}
	clearedconfigs        bool
	statuses              map[uuid.UUID]struct{}
	removedstatuses       map[uuid.UUID]struct{}
	clearedstatuses       bool
	done                  bool
	oldValue              func(context.Context) (*Check, error)
	predicates            []predicate.Check
}

var _ ent.Mutation = (*CheckMutation)(nil)

// checkOption allows management of the mutation configuration using functional options.
type checkOption func(*CheckMutation)

// newCheckMutation creates new mutation for the Check entity.
func newCheckMutation(c config, op Op, opts ...checkOption) *CheckMutation {
	m := &CheckMutation{
		config:        c,
		op:            op,
		typ:           TypeCheck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckID sets the ID field of the mutation.
func withCheckID(id uuid.UUID) checkOption {
	return func(m *CheckMutation) {
		var (
			err   error
			once  sync.Once
			value *Check
		)
		m.oldValue = func(ctx context.Context) (*Check, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Check.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheck sets the old Check of the mutation.
func withCheck(node *Check) checkOption {
	return func(m *CheckMutation) {
		m.oldValue = func(context.Context) (*Check, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Check entities.
func (m *CheckMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Check.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CheckMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CheckMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CheckMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CheckMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CheckMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CheckMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CheckMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CheckMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CheckMutation) ResetName() {
	m.name = nil
}

// SetSource sets the "source" field.
func (m *CheckMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *CheckMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *CheckMutation) ResetSource() {
	m.source = nil
}

// SetWeight sets the "weight" field.
func (m *CheckMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *CheckMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *CheckMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *CheckMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *CheckMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetConfig sets the "config" field.
func (m *CheckMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *CheckMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *CheckMutation) ResetConfig() {
	m._config = nil
}

// SetEditableFields sets the "editable_fields" field.
func (m *CheckMutation) SetEditableFields(s []string) {
	m.editable_fields = &s
	m.appendeditable_fields = nil
}

// EditableFields returns the value of the "editable_fields" field in the mutation.
func (m *CheckMutation) EditableFields() (r []string, exists bool) {
	v := m.editable_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldEditableFields returns the old "editable_fields" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldEditableFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditableFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditableFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditableFields: %w", err)
	}
	return oldValue.EditableFields, nil
}

// AppendEditableFields adds s to the "editable_fields" field.
func (m *CheckMutation) AppendEditableFields(s []string) {
	m.appendeditable_fields = append(m.appendeditable_fields, s...)
}

// AppendedEditableFields returns the list of values that were appended to the "editable_fields" field in this mutation.
func (m *CheckMutation) AppendedEditableFields() ([]string, bool) {
	if len(m.appendeditable_fields) == 0 {
		return nil, false
	}
	return m.appendeditable_fields, true
}

// ResetEditableFields resets all changes to the "editable_fields" field.
func (m *CheckMutation) ResetEditableFields() {
	m.editable_fields = nil
	m.appendeditable_fields = nil
}

// AddConfigIDs adds the "configs" edge to the CheckConfig entity by ids.
func (m *CheckMutation) AddConfigIDs(ids ...uuid.UUID) {
	if m.configs == nil {
		m.configs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.configs[ids[i]] = struct{}{}
	}
}

// ClearConfigs clears the "configs" edge to the CheckConfig entity.
func (m *CheckMutation) ClearConfigs() {
	m.clearedconfigs = true
}

// ConfigsCleared reports if the "configs" edge to the CheckConfig entity was cleared.
func (m *CheckMutation) ConfigsCleared() bool {
	return m.clearedconfigs
}

// RemoveConfigIDs removes the "configs" edge to the CheckConfig entity by IDs.
func (m *CheckMutation) RemoveConfigIDs(ids ...uuid.UUID) {
	if m.removedconfigs == nil {
		m.removedconfigs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.configs, ids[i])
		m.removedconfigs[ids[i]] = struct{}{}
	}
}

// RemovedConfigs returns the removed IDs of the "configs" edge to the CheckConfig entity.
func (m *CheckMutation) RemovedConfigsIDs() (ids []uuid.UUID) {
	for id := range m.removedconfigs {
		ids = append(ids, id)
	}
	return
}

// ConfigsIDs returns the "configs" edge IDs in the mutation.
func (m *CheckMutation) ConfigsIDs() (ids []uuid.UUID) {
	for id := range m.configs {
		ids = append(ids, id)
	}
	return
}

// ResetConfigs resets all changes to the "configs" edge.
func (m *CheckMutation) ResetConfigs() {
	m.configs = nil
	m.clearedconfigs = false
	m.removedconfigs = nil
}

// AddStatusIDs adds the "statuses" edge to the Status entity by ids.
func (m *CheckMutation) AddStatusIDs(ids ...uuid.UUID) {
	if m.statuses == nil {
		m.statuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.statuses[ids[i]] = struct{}{}
	}
}

// ClearStatuses clears the "statuses" edge to the Status entity.
func (m *CheckMutation) ClearStatuses() {
	m.clearedstatuses = true
}

// StatusesCleared reports if the "statuses" edge to the Status entity was cleared.
func (m *CheckMutation) StatusesCleared() bool {
	return m.clearedstatuses
}

// RemoveStatusIDs removes the "statuses" edge to the Status entity by IDs.
func (m *CheckMutation) RemoveStatusIDs(ids ...uuid.UUID) {
	if m.removedstatuses == nil {
		m.removedstatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.statuses, ids[i])
		m.removedstatuses[ids[i]] = struct{}{}
	}
}

// RemovedStatuses returns the removed IDs of the "statuses" edge to the Status entity.
func (m *CheckMutation) RemovedStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removedstatuses {
		ids = append(ids, id)
	}
	return
}

// StatusesIDs returns the "statuses" edge IDs in the mutation.
func (m *CheckMutation) StatusesIDs() (ids []uuid.UUID) {
	for id := range m.statuses {
		ids = append(ids, id)
	}
	return
}

// ResetStatuses resets all changes to the "statuses" edge.
func (m *CheckMutation) ResetStatuses() {
	m.statuses = nil
	m.clearedstatuses = false
	m.removedstatuses = nil
}

// Where appends a list predicates to the CheckMutation builder.
func (m *CheckMutation) Where(ps ...predicate.Check) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Check, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Check).
func (m *CheckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, check.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, check.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, check.FieldName)
	}
	if m.source != nil {
		fields = append(fields, check.FieldSource)
	}
	if m.weight != nil {
		fields = append(fields, check.FieldWeight)
	}
	if m._config != nil {
		fields = append(fields, check.FieldConfig)
	}
	if m.editable_fields != nil {
		fields = append(fields, check.FieldEditableFields)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case check.FieldCreateTime:
		return m.CreateTime()
	case check.FieldUpdateTime:
		return m.UpdateTime()
	case check.FieldName:
		return m.Name()
	case check.FieldSource:
		return m.Source()
	case check.FieldWeight:
		return m.Weight()
	case check.FieldConfig:
		return m.Config()
	case check.FieldEditableFields:
		return m.EditableFields()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case check.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case check.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case check.FieldName:
		return m.OldName(ctx)
	case check.FieldSource:
		return m.OldSource(ctx)
	case check.FieldWeight:
		return m.OldWeight(ctx)
	case check.FieldConfig:
		return m.OldConfig(ctx)
	case check.FieldEditableFields:
		return m.OldEditableFields(ctx)
	}
	return nil, fmt.Errorf("unknown Check field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case check.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case check.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case check.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case check.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case check.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case check.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case check.FieldEditableFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditableFields(v)
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, check.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case check.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) AddField(name string, value ent.Value) error {
	switch name {
	case check.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Check numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Check nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckMutation) ResetField(name string) error {
	switch name {
	case check.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case check.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case check.FieldName:
		m.ResetName()
		return nil
	case check.FieldSource:
		m.ResetSource()
		return nil
	case check.FieldWeight:
		m.ResetWeight()
		return nil
	case check.FieldConfig:
		m.ResetConfig()
		return nil
	case check.FieldEditableFields:
		m.ResetEditableFields()
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.configs != nil {
		edges = append(edges, check.EdgeConfigs)
	}
	if m.statuses != nil {
		edges = append(edges, check.EdgeStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case check.EdgeConfigs:
		ids := make([]ent.Value, 0, len(m.configs))
		for id := range m.configs {
			ids = append(ids, id)
		}
		return ids
	case check.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.statuses))
		for id := range m.statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconfigs != nil {
		edges = append(edges, check.EdgeConfigs)
	}
	if m.removedstatuses != nil {
		edges = append(edges, check.EdgeStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case check.EdgeConfigs:
		ids := make([]ent.Value, 0, len(m.removedconfigs))
		for id := range m.removedconfigs {
			ids = append(ids, id)
		}
		return ids
	case check.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.removedstatuses))
		for id := range m.removedstatuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconfigs {
		edges = append(edges, check.EdgeConfigs)
	}
	if m.clearedstatuses {
		edges = append(edges, check.EdgeStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckMutation) EdgeCleared(name string) bool {
	switch name {
	case check.EdgeConfigs:
		return m.clearedconfigs
	case check.EdgeStatuses:
		return m.clearedstatuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Check unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckMutation) ResetEdge(name string) error {
	switch name {
	case check.EdgeConfigs:
		m.ResetConfigs()
		return nil
	case check.EdgeStatuses:
		m.ResetStatuses()
		return nil
	}
	return fmt.Errorf("unknown Check edge %s", name)
}

// CheckConfigMutation represents an operation that mutates the CheckConfig nodes in the graph.
type CheckConfigMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	_config       *map[string]interface{}
	clearedFields map[string]struct{}
	check         *uuid.UUID
	clearedcheck  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*CheckConfig, error)
	predicates    []predicate.CheckConfig
}

var _ ent.Mutation = (*CheckConfigMutation)(nil)

// checkconfigOption allows management of the mutation configuration using functional options.
type checkconfigOption func(*CheckConfigMutation)

// newCheckConfigMutation creates new mutation for the CheckConfig entity.
func newCheckConfigMutation(c config, op Op, opts ...checkconfigOption) *CheckConfigMutation {
	m := &CheckConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckConfigID sets the ID field of the mutation.
func withCheckConfigID(id uuid.UUID) checkconfigOption {
	return func(m *CheckConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckConfig
		)
		m.oldValue = func(ctx context.Context) (*CheckConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckConfig sets the old CheckConfig of the mutation.
func withCheckConfig(node *CheckConfig) checkconfigOption {
	return func(m *CheckConfigMutation) {
		m.oldValue = func(context.Context) (*CheckConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CheckConfig entities.
func (m *CheckConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CheckConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CheckConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CheckConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CheckConfig entity.
// If the CheckConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CheckConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CheckConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CheckConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CheckConfig entity.
// If the CheckConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CheckConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetConfig sets the "config" field.
func (m *CheckConfigMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *CheckConfigMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the CheckConfig entity.
// If the CheckConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckConfigMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *CheckConfigMutation) ResetConfig() {
	m._config = nil
}

// SetCheckID sets the "check_id" field.
func (m *CheckConfigMutation) SetCheckID(u uuid.UUID) {
	m.check = &u
}

// CheckID returns the value of the "check_id" field in the mutation.
func (m *CheckConfigMutation) CheckID() (r uuid.UUID, exists bool) {
	v := m.check
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckID returns the old "check_id" field's value of the CheckConfig entity.
// If the CheckConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckConfigMutation) OldCheckID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckID: %w", err)
	}
	return oldValue.CheckID, nil
}

// ResetCheckID resets all changes to the "check_id" field.
func (m *CheckConfigMutation) ResetCheckID() {
	m.check = nil
}

// SetUserID sets the "user_id" field.
func (m *CheckConfigMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CheckConfigMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CheckConfig entity.
// If the CheckConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckConfigMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CheckConfigMutation) ResetUserID() {
	m.user = nil
}

// ClearCheck clears the "check" edge to the Check entity.
func (m *CheckConfigMutation) ClearCheck() {
	m.clearedcheck = true
	m.clearedFields[checkconfig.FieldCheckID] = struct{}{}
}

// CheckCleared reports if the "check" edge to the Check entity was cleared.
func (m *CheckConfigMutation) CheckCleared() bool {
	return m.clearedcheck
}

// CheckIDs returns the "check" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CheckID instead. It exists only for internal usage by the builders.
func (m *CheckConfigMutation) CheckIDs() (ids []uuid.UUID) {
	if id := m.check; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheck resets all changes to the "check" edge.
func (m *CheckConfigMutation) ResetCheck() {
	m.check = nil
	m.clearedcheck = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *CheckConfigMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[checkconfig.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CheckConfigMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CheckConfigMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CheckConfigMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CheckConfigMutation builder.
func (m *CheckConfigMutation) Where(ps ...predicate.CheckConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CheckConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CheckConfig).
func (m *CheckConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckConfigMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, checkconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, checkconfig.FieldUpdateTime)
	}
	if m._config != nil {
		fields = append(fields, checkconfig.FieldConfig)
	}
	if m.check != nil {
		fields = append(fields, checkconfig.FieldCheckID)
	}
	if m.user != nil {
		fields = append(fields, checkconfig.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkconfig.FieldCreateTime:
		return m.CreateTime()
	case checkconfig.FieldUpdateTime:
		return m.UpdateTime()
	case checkconfig.FieldConfig:
		return m.Config()
	case checkconfig.FieldCheckID:
		return m.CheckID()
	case checkconfig.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case checkconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case checkconfig.FieldConfig:
		return m.OldConfig(ctx)
	case checkconfig.FieldCheckID:
		return m.OldCheckID(ctx)
	case checkconfig.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown CheckConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case checkconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case checkconfig.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case checkconfig.FieldCheckID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckID(v)
		return nil
	case checkconfig.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown CheckConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CheckConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CheckConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckConfigMutation) ResetField(name string) error {
	switch name {
	case checkconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case checkconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case checkconfig.FieldConfig:
		m.ResetConfig()
		return nil
	case checkconfig.FieldCheckID:
		m.ResetCheckID()
		return nil
	case checkconfig.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown CheckConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.check != nil {
		edges = append(edges, checkconfig.EdgeCheck)
	}
	if m.user != nil {
		edges = append(edges, checkconfig.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkconfig.EdgeCheck:
		if id := m.check; id != nil {
			return []ent.Value{*id}
		}
	case checkconfig.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcheck {
		edges = append(edges, checkconfig.EdgeCheck)
	}
	if m.cleareduser {
		edges = append(edges, checkconfig.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case checkconfig.EdgeCheck:
		return m.clearedcheck
	case checkconfig.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckConfigMutation) ClearEdge(name string) error {
	switch name {
	case checkconfig.EdgeCheck:
		m.ClearCheck()
		return nil
	case checkconfig.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CheckConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckConfigMutation) ResetEdge(name string) error {
	switch name {
	case checkconfig.EdgeCheck:
		m.ResetCheck()
		return nil
	case checkconfig.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CheckConfig edge %s", name)
}

// InjectMutation represents an operation that mutates the Inject nodes in the graph.
type InjectMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	title              *string
	start_time         *time.Time
	end_time           *time.Time
	files              *[]structs.File
	appendfiles        []structs.File
	rubric             *structs.RubricTemplate
	clearedFields      map[string]struct{}
	submissions        map[uuid.UUID]struct{}
	removedsubmissions map[uuid.UUID]struct{}
	clearedsubmissions bool
	done               bool
	oldValue           func(context.Context) (*Inject, error)
	predicates         []predicate.Inject
}

var _ ent.Mutation = (*InjectMutation)(nil)

// injectOption allows management of the mutation configuration using functional options.
type injectOption func(*InjectMutation)

// newInjectMutation creates new mutation for the Inject entity.
func newInjectMutation(c config, op Op, opts ...injectOption) *InjectMutation {
	m := &InjectMutation{
		config:        c,
		op:            op,
		typ:           TypeInject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInjectID sets the ID field of the mutation.
func withInjectID(id uuid.UUID) injectOption {
	return func(m *InjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Inject
		)
		m.oldValue = func(ctx context.Context) (*Inject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInject sets the old Inject of the mutation.
func withInject(node *Inject) injectOption {
	return func(m *InjectMutation) {
		m.oldValue = func(context.Context) (*Inject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inject entities.
func (m *InjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *InjectMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InjectMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InjectMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InjectMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InjectMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InjectMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *InjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *InjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *InjectMutation) ResetTitle() {
	m.title = nil
}

// SetStartTime sets the "start_time" field.
func (m *InjectMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *InjectMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *InjectMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *InjectMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *InjectMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *InjectMutation) ResetEndTime() {
	m.end_time = nil
}

// SetFiles sets the "files" field.
func (m *InjectMutation) SetFiles(s []structs.File) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *InjectMutation) Files() (r []structs.File, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldFiles(ctx context.Context) (v []structs.File, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *InjectMutation) AppendFiles(s []structs.File) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *InjectMutation) AppendedFiles() ([]structs.File, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ResetFiles resets all changes to the "files" field.
func (m *InjectMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
}

// SetRubric sets the "rubric" field.
func (m *InjectMutation) SetRubric(st structs.RubricTemplate) {
	m.rubric = &st
}

// Rubric returns the value of the "rubric" field in the mutation.
func (m *InjectMutation) Rubric() (r structs.RubricTemplate, exists bool) {
	v := m.rubric
	if v == nil {
		return
	}
	return *v, true
}

// OldRubric returns the old "rubric" field's value of the Inject entity.
// If the Inject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectMutation) OldRubric(ctx context.Context) (v structs.RubricTemplate, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRubric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRubric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRubric: %w", err)
	}
	return oldValue.Rubric, nil
}

// ResetRubric resets all changes to the "rubric" field.
func (m *InjectMutation) ResetRubric() {
	m.rubric = nil
}

// AddSubmissionIDs adds the "submissions" edge to the InjectSubmission entity by ids.
func (m *InjectMutation) AddSubmissionIDs(ids ...uuid.UUID) {
	if m.submissions == nil {
		m.submissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the InjectSubmission entity.
func (m *InjectMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the InjectSubmission entity was cleared.
func (m *InjectMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the InjectSubmission entity by IDs.
func (m *InjectMutation) RemoveSubmissionIDs(ids ...uuid.UUID) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the InjectSubmission entity.
func (m *InjectMutation) RemovedSubmissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *InjectMutation) SubmissionsIDs() (ids []uuid.UUID) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *InjectMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// Where appends a list predicates to the InjectMutation builder.
func (m *InjectMutation) Where(ps ...predicate.Inject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inject).
func (m *InjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, inject.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, inject.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, inject.FieldTitle)
	}
	if m.start_time != nil {
		fields = append(fields, inject.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, inject.FieldEndTime)
	}
	if m.files != nil {
		fields = append(fields, inject.FieldFiles)
	}
	if m.rubric != nil {
		fields = append(fields, inject.FieldRubric)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inject.FieldCreateTime:
		return m.CreateTime()
	case inject.FieldUpdateTime:
		return m.UpdateTime()
	case inject.FieldTitle:
		return m.Title()
	case inject.FieldStartTime:
		return m.StartTime()
	case inject.FieldEndTime:
		return m.EndTime()
	case inject.FieldFiles:
		return m.Files()
	case inject.FieldRubric:
		return m.Rubric()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inject.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case inject.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case inject.FieldTitle:
		return m.OldTitle(ctx)
	case inject.FieldStartTime:
		return m.OldStartTime(ctx)
	case inject.FieldEndTime:
		return m.OldEndTime(ctx)
	case inject.FieldFiles:
		return m.OldFiles(ctx)
	case inject.FieldRubric:
		return m.OldRubric(ctx)
	}
	return nil, fmt.Errorf("unknown Inject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inject.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case inject.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case inject.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case inject.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case inject.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case inject.FieldFiles:
		v, ok := value.([]structs.File)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	case inject.FieldRubric:
		v, ok := value.(structs.RubricTemplate)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRubric(v)
		return nil
	}
	return fmt.Errorf("unknown Inject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Inject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Inject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InjectMutation) ResetField(name string) error {
	switch name {
	case inject.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case inject.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case inject.FieldTitle:
		m.ResetTitle()
		return nil
	case inject.FieldStartTime:
		m.ResetStartTime()
		return nil
	case inject.FieldEndTime:
		m.ResetEndTime()
		return nil
	case inject.FieldFiles:
		m.ResetFiles()
		return nil
	case inject.FieldRubric:
		m.ResetRubric()
		return nil
	}
	return fmt.Errorf("unknown Inject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.submissions != nil {
		edges = append(edges, inject.EdgeSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inject.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubmissions != nil {
		edges = append(edges, inject.EdgeSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inject.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubmissions {
		edges = append(edges, inject.EdgeSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InjectMutation) EdgeCleared(name string) bool {
	switch name {
	case inject.EdgeSubmissions:
		return m.clearedsubmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Inject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InjectMutation) ResetEdge(name string) error {
	switch name {
	case inject.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	}
	return fmt.Errorf("unknown Inject edge %s", name)
}

// InjectSubmissionMutation represents an operation that mutates the InjectSubmission nodes in the graph.
type InjectSubmissionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	files         *[]structs.File
	appendfiles   []structs.File
	notes         *string
	rubric        **structs.Rubric
	graded        *bool
	clearedFields map[string]struct{}
	inject        *uuid.UUID
	clearedinject bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*InjectSubmission, error)
	predicates    []predicate.InjectSubmission
}

var _ ent.Mutation = (*InjectSubmissionMutation)(nil)

// injectsubmissionOption allows management of the mutation configuration using functional options.
type injectsubmissionOption func(*InjectSubmissionMutation)

// newInjectSubmissionMutation creates new mutation for the InjectSubmission entity.
func newInjectSubmissionMutation(c config, op Op, opts ...injectsubmissionOption) *InjectSubmissionMutation {
	m := &InjectSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeInjectSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInjectSubmissionID sets the ID field of the mutation.
func withInjectSubmissionID(id uuid.UUID) injectsubmissionOption {
	return func(m *InjectSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *InjectSubmission
		)
		m.oldValue = func(ctx context.Context) (*InjectSubmission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InjectSubmission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInjectSubmission sets the old InjectSubmission of the mutation.
func withInjectSubmission(node *InjectSubmission) injectsubmissionOption {
	return func(m *InjectSubmissionMutation) {
		m.oldValue = func(context.Context) (*InjectSubmission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InjectSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InjectSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InjectSubmission entities.
func (m *InjectSubmissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InjectSubmissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InjectSubmissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InjectSubmission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *InjectSubmissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InjectSubmissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InjectSubmissionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InjectSubmissionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InjectSubmissionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InjectSubmissionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFiles sets the "files" field.
func (m *InjectSubmissionMutation) SetFiles(s []structs.File) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *InjectSubmissionMutation) Files() (r []structs.File, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldFiles(ctx context.Context) (v []structs.File, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *InjectSubmissionMutation) AppendFiles(s []structs.File) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *InjectSubmissionMutation) AppendedFiles() ([]structs.File, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ResetFiles resets all changes to the "files" field.
func (m *InjectSubmissionMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
}

// SetInjectID sets the "inject_id" field.
func (m *InjectSubmissionMutation) SetInjectID(u uuid.UUID) {
	m.inject = &u
}

// InjectID returns the value of the "inject_id" field in the mutation.
func (m *InjectSubmissionMutation) InjectID() (r uuid.UUID, exists bool) {
	v := m.inject
	if v == nil {
		return
	}
	return *v, true
}

// OldInjectID returns the old "inject_id" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldInjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInjectID: %w", err)
	}
	return oldValue.InjectID, nil
}

// ResetInjectID resets all changes to the "inject_id" field.
func (m *InjectSubmissionMutation) ResetInjectID() {
	m.inject = nil
}

// SetUserID sets the "user_id" field.
func (m *InjectSubmissionMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InjectSubmissionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InjectSubmissionMutation) ResetUserID() {
	m.user = nil
}

// SetNotes sets the "notes" field.
func (m *InjectSubmissionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *InjectSubmissionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *InjectSubmissionMutation) ResetNotes() {
	m.notes = nil
}

// SetRubric sets the "rubric" field.
func (m *InjectSubmissionMutation) SetRubric(s *structs.Rubric) {
	m.rubric = &s
}

// Rubric returns the value of the "rubric" field in the mutation.
func (m *InjectSubmissionMutation) Rubric() (r *structs.Rubric, exists bool) {
	v := m.rubric
	if v == nil {
		return
	}
	return *v, true
}

// OldRubric returns the old "rubric" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldRubric(ctx context.Context) (v *structs.Rubric, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRubric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRubric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRubric: %w", err)
	}
	return oldValue.Rubric, nil
}

// ClearRubric clears the value of the "rubric" field.
func (m *InjectSubmissionMutation) ClearRubric() {
	m.rubric = nil
	m.clearedFields[injectsubmission.FieldRubric] = struct{}{}
}

// RubricCleared returns if the "rubric" field was cleared in this mutation.
func (m *InjectSubmissionMutation) RubricCleared() bool {
	_, ok := m.clearedFields[injectsubmission.FieldRubric]
	return ok
}

// ResetRubric resets all changes to the "rubric" field.
func (m *InjectSubmissionMutation) ResetRubric() {
	m.rubric = nil
	delete(m.clearedFields, injectsubmission.FieldRubric)
}

// SetGraded sets the "graded" field.
func (m *InjectSubmissionMutation) SetGraded(b bool) {
	m.graded = &b
}

// Graded returns the value of the "graded" field in the mutation.
func (m *InjectSubmissionMutation) Graded() (r bool, exists bool) {
	v := m.graded
	if v == nil {
		return
	}
	return *v, true
}

// OldGraded returns the old "graded" field's value of the InjectSubmission entity.
// If the InjectSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InjectSubmissionMutation) OldGraded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraded: %w", err)
	}
	return oldValue.Graded, nil
}

// ResetGraded resets all changes to the "graded" field.
func (m *InjectSubmissionMutation) ResetGraded() {
	m.graded = nil
}

// ClearInject clears the "inject" edge to the Inject entity.
func (m *InjectSubmissionMutation) ClearInject() {
	m.clearedinject = true
	m.clearedFields[injectsubmission.FieldInjectID] = struct{}{}
}

// InjectCleared reports if the "inject" edge to the Inject entity was cleared.
func (m *InjectSubmissionMutation) InjectCleared() bool {
	return m.clearedinject
}

// InjectIDs returns the "inject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InjectID instead. It exists only for internal usage by the builders.
func (m *InjectSubmissionMutation) InjectIDs() (ids []uuid.UUID) {
	if id := m.inject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInject resets all changes to the "inject" edge.
func (m *InjectSubmissionMutation) ResetInject() {
	m.inject = nil
	m.clearedinject = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *InjectSubmissionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[injectsubmission.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InjectSubmissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InjectSubmissionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InjectSubmissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the InjectSubmissionMutation builder.
func (m *InjectSubmissionMutation) Where(ps ...predicate.InjectSubmission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InjectSubmissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InjectSubmissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InjectSubmission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InjectSubmissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InjectSubmissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InjectSubmission).
func (m *InjectSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InjectSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, injectsubmission.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, injectsubmission.FieldUpdateTime)
	}
	if m.files != nil {
		fields = append(fields, injectsubmission.FieldFiles)
	}
	if m.inject != nil {
		fields = append(fields, injectsubmission.FieldInjectID)
	}
	if m.user != nil {
		fields = append(fields, injectsubmission.FieldUserID)
	}
	if m.notes != nil {
		fields = append(fields, injectsubmission.FieldNotes)
	}
	if m.rubric != nil {
		fields = append(fields, injectsubmission.FieldRubric)
	}
	if m.graded != nil {
		fields = append(fields, injectsubmission.FieldGraded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InjectSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case injectsubmission.FieldCreateTime:
		return m.CreateTime()
	case injectsubmission.FieldUpdateTime:
		return m.UpdateTime()
	case injectsubmission.FieldFiles:
		return m.Files()
	case injectsubmission.FieldInjectID:
		return m.InjectID()
	case injectsubmission.FieldUserID:
		return m.UserID()
	case injectsubmission.FieldNotes:
		return m.Notes()
	case injectsubmission.FieldRubric:
		return m.Rubric()
	case injectsubmission.FieldGraded:
		return m.Graded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InjectSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case injectsubmission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case injectsubmission.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case injectsubmission.FieldFiles:
		return m.OldFiles(ctx)
	case injectsubmission.FieldInjectID:
		return m.OldInjectID(ctx)
	case injectsubmission.FieldUserID:
		return m.OldUserID(ctx)
	case injectsubmission.FieldNotes:
		return m.OldNotes(ctx)
	case injectsubmission.FieldRubric:
		return m.OldRubric(ctx)
	case injectsubmission.FieldGraded:
		return m.OldGraded(ctx)
	}
	return nil, fmt.Errorf("unknown InjectSubmission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InjectSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case injectsubmission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case injectsubmission.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case injectsubmission.FieldFiles:
		v, ok := value.([]structs.File)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	case injectsubmission.FieldInjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInjectID(v)
		return nil
	case injectsubmission.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case injectsubmission.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case injectsubmission.FieldRubric:
		v, ok := value.(*structs.Rubric)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRubric(v)
		return nil
	case injectsubmission.FieldGraded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraded(v)
		return nil
	}
	return fmt.Errorf("unknown InjectSubmission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InjectSubmissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InjectSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InjectSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InjectSubmission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InjectSubmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(injectsubmission.FieldRubric) {
		fields = append(fields, injectsubmission.FieldRubric)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InjectSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InjectSubmissionMutation) ClearField(name string) error {
	switch name {
	case injectsubmission.FieldRubric:
		m.ClearRubric()
		return nil
	}
	return fmt.Errorf("unknown InjectSubmission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InjectSubmissionMutation) ResetField(name string) error {
	switch name {
	case injectsubmission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case injectsubmission.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case injectsubmission.FieldFiles:
		m.ResetFiles()
		return nil
	case injectsubmission.FieldInjectID:
		m.ResetInjectID()
		return nil
	case injectsubmission.FieldUserID:
		m.ResetUserID()
		return nil
	case injectsubmission.FieldNotes:
		m.ResetNotes()
		return nil
	case injectsubmission.FieldRubric:
		m.ResetRubric()
		return nil
	case injectsubmission.FieldGraded:
		m.ResetGraded()
		return nil
	}
	return fmt.Errorf("unknown InjectSubmission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InjectSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.inject != nil {
		edges = append(edges, injectsubmission.EdgeInject)
	}
	if m.user != nil {
		edges = append(edges, injectsubmission.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InjectSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case injectsubmission.EdgeInject:
		if id := m.inject; id != nil {
			return []ent.Value{*id}
		}
	case injectsubmission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InjectSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InjectSubmissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InjectSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinject {
		edges = append(edges, injectsubmission.EdgeInject)
	}
	if m.cleareduser {
		edges = append(edges, injectsubmission.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InjectSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case injectsubmission.EdgeInject:
		return m.clearedinject
	case injectsubmission.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InjectSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case injectsubmission.EdgeInject:
		m.ClearInject()
		return nil
	case injectsubmission.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown InjectSubmission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InjectSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case injectsubmission.EdgeInject:
		m.ResetInject()
		return nil
	case injectsubmission.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown InjectSubmission edge %s", name)
}

// MinionMutation represents an operation that mutates the Minion nodes in the graph.
type MinionMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	ip              *string
	deactivated     *bool
	clearedFields   map[string]struct{}
	statuses        map[uuid.UUID]struct{}
	removedstatuses map[uuid.UUID]struct{}
	clearedstatuses bool
	done            bool
	oldValue        func(context.Context) (*Minion, error)
	predicates      []predicate.Minion
}

var _ ent.Mutation = (*MinionMutation)(nil)

// minionOption allows management of the mutation configuration using functional options.
type minionOption func(*MinionMutation)

// newMinionMutation creates new mutation for the Minion entity.
func newMinionMutation(c config, op Op, opts ...minionOption) *MinionMutation {
	m := &MinionMutation{
		config:        c,
		op:            op,
		typ:           TypeMinion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMinionID sets the ID field of the mutation.
func withMinionID(id uuid.UUID) minionOption {
	return func(m *MinionMutation) {
		var (
			err   error
			once  sync.Once
			value *Minion
		)
		m.oldValue = func(ctx context.Context) (*Minion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Minion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMinion sets the old Minion of the mutation.
func withMinion(node *Minion) minionOption {
	return func(m *MinionMutation) {
		m.oldValue = func(context.Context) (*Minion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MinionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MinionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Minion entities.
func (m *MinionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MinionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MinionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Minion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MinionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MinionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Minion entity.
// If the Minion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MinionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MinionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MinionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MinionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Minion entity.
// If the Minion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MinionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MinionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *MinionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MinionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Minion entity.
// If the Minion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MinionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MinionMutation) ResetName() {
	m.name = nil
}

// SetIP sets the "ip" field.
func (m *MinionMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *MinionMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Minion entity.
// If the Minion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MinionMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *MinionMutation) ResetIP() {
	m.ip = nil
}

// SetDeactivated sets the "deactivated" field.
func (m *MinionMutation) SetDeactivated(b bool) {
	m.deactivated = &b
}

// Deactivated returns the value of the "deactivated" field in the mutation.
func (m *MinionMutation) Deactivated() (r bool, exists bool) {
	v := m.deactivated
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivated returns the old "deactivated" field's value of the Minion entity.
// If the Minion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MinionMutation) OldDeactivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivated: %w", err)
	}
	return oldValue.Deactivated, nil
}

// ResetDeactivated resets all changes to the "deactivated" field.
func (m *MinionMutation) ResetDeactivated() {
	m.deactivated = nil
}

// AddStatusIDs adds the "statuses" edge to the Status entity by ids.
func (m *MinionMutation) AddStatusIDs(ids ...uuid.UUID) {
	if m.statuses == nil {
		m.statuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.statuses[ids[i]] = struct{}{}
	}
}

// ClearStatuses clears the "statuses" edge to the Status entity.
func (m *MinionMutation) ClearStatuses() {
	m.clearedstatuses = true
}

// StatusesCleared reports if the "statuses" edge to the Status entity was cleared.
func (m *MinionMutation) StatusesCleared() bool {
	return m.clearedstatuses
}

// RemoveStatusIDs removes the "statuses" edge to the Status entity by IDs.
func (m *MinionMutation) RemoveStatusIDs(ids ...uuid.UUID) {
	if m.removedstatuses == nil {
		m.removedstatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.statuses, ids[i])
		m.removedstatuses[ids[i]] = struct{}{}
	}
}

// RemovedStatuses returns the removed IDs of the "statuses" edge to the Status entity.
func (m *MinionMutation) RemovedStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removedstatuses {
		ids = append(ids, id)
	}
	return
}

// StatusesIDs returns the "statuses" edge IDs in the mutation.
func (m *MinionMutation) StatusesIDs() (ids []uuid.UUID) {
	for id := range m.statuses {
		ids = append(ids, id)
	}
	return
}

// ResetStatuses resets all changes to the "statuses" edge.
func (m *MinionMutation) ResetStatuses() {
	m.statuses = nil
	m.clearedstatuses = false
	m.removedstatuses = nil
}

// Where appends a list predicates to the MinionMutation builder.
func (m *MinionMutation) Where(ps ...predicate.Minion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MinionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MinionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Minion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MinionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MinionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Minion).
func (m *MinionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MinionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, minion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, minion.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, minion.FieldName)
	}
	if m.ip != nil {
		fields = append(fields, minion.FieldIP)
	}
	if m.deactivated != nil {
		fields = append(fields, minion.FieldDeactivated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MinionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case minion.FieldCreateTime:
		return m.CreateTime()
	case minion.FieldUpdateTime:
		return m.UpdateTime()
	case minion.FieldName:
		return m.Name()
	case minion.FieldIP:
		return m.IP()
	case minion.FieldDeactivated:
		return m.Deactivated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MinionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case minion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case minion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case minion.FieldName:
		return m.OldName(ctx)
	case minion.FieldIP:
		return m.OldIP(ctx)
	case minion.FieldDeactivated:
		return m.OldDeactivated(ctx)
	}
	return nil, fmt.Errorf("unknown Minion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MinionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case minion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case minion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case minion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case minion.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case minion.FieldDeactivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivated(v)
		return nil
	}
	return fmt.Errorf("unknown Minion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MinionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MinionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MinionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Minion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MinionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MinionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MinionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Minion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MinionMutation) ResetField(name string) error {
	switch name {
	case minion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case minion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case minion.FieldName:
		m.ResetName()
		return nil
	case minion.FieldIP:
		m.ResetIP()
		return nil
	case minion.FieldDeactivated:
		m.ResetDeactivated()
		return nil
	}
	return fmt.Errorf("unknown Minion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MinionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statuses != nil {
		edges = append(edges, minion.EdgeStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MinionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case minion.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.statuses))
		for id := range m.statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MinionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatuses != nil {
		edges = append(edges, minion.EdgeStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MinionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case minion.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.removedstatuses))
		for id := range m.removedstatuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MinionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstatuses {
		edges = append(edges, minion.EdgeStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MinionMutation) EdgeCleared(name string) bool {
	switch name {
	case minion.EdgeStatuses:
		return m.clearedstatuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MinionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Minion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MinionMutation) ResetEdge(name string) error {
	switch name {
	case minion.EdgeStatuses:
		m.ResetStatuses()
		return nil
	}
	return fmt.Errorf("unknown Minion edge %s", name)
}

// RoundMutation represents an operation that mutates the Round nodes in the graph.
type RoundMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	number             *int
	addnumber          *int
	complete           *bool
	clearedFields      map[string]struct{}
	statuses           map[uuid.UUID]struct{}
	removedstatuses    map[uuid.UUID]struct{}
	clearedstatuses    bool
	scoreCaches        map[uuid.UUID]struct{}
	removedscoreCaches map[uuid.UUID]struct{}
	clearedscoreCaches bool
	done               bool
	oldValue           func(context.Context) (*Round, error)
	predicates         []predicate.Round
}

var _ ent.Mutation = (*RoundMutation)(nil)

// roundOption allows management of the mutation configuration using functional options.
type roundOption func(*RoundMutation)

// newRoundMutation creates new mutation for the Round entity.
func newRoundMutation(c config, op Op, opts ...roundOption) *RoundMutation {
	m := &RoundMutation{
		config:        c,
		op:            op,
		typ:           TypeRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundID sets the ID field of the mutation.
func withRoundID(id uuid.UUID) roundOption {
	return func(m *RoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Round
		)
		m.oldValue = func(ctx context.Context) (*Round, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Round.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRound sets the old Round of the mutation.
func withRound(node *Round) roundOption {
	return func(m *RoundMutation) {
		m.oldValue = func(context.Context) (*Round, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Round entities.
func (m *RoundMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Round.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RoundMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoundMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoundMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RoundMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoundMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoundMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNumber sets the "number" field.
func (m *RoundMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *RoundMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *RoundMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *RoundMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *RoundMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetComplete sets the "complete" field.
func (m *RoundMutation) SetComplete(b bool) {
	m.complete = &b
}

// Complete returns the value of the "complete" field in the mutation.
func (m *RoundMutation) Complete() (r bool, exists bool) {
	v := m.complete
	if v == nil {
		return
	}
	return *v, true
}

// OldComplete returns the old "complete" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldComplete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplete: %w", err)
	}
	return oldValue.Complete, nil
}

// ResetComplete resets all changes to the "complete" field.
func (m *RoundMutation) ResetComplete() {
	m.complete = nil
}

// AddStatusIDs adds the "statuses" edge to the Status entity by ids.
func (m *RoundMutation) AddStatusIDs(ids ...uuid.UUID) {
	if m.statuses == nil {
		m.statuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.statuses[ids[i]] = struct{}{}
	}
}

// ClearStatuses clears the "statuses" edge to the Status entity.
func (m *RoundMutation) ClearStatuses() {
	m.clearedstatuses = true
}

// StatusesCleared reports if the "statuses" edge to the Status entity was cleared.
func (m *RoundMutation) StatusesCleared() bool {
	return m.clearedstatuses
}

// RemoveStatusIDs removes the "statuses" edge to the Status entity by IDs.
func (m *RoundMutation) RemoveStatusIDs(ids ...uuid.UUID) {
	if m.removedstatuses == nil {
		m.removedstatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.statuses, ids[i])
		m.removedstatuses[ids[i]] = struct{}{}
	}
}

// RemovedStatuses returns the removed IDs of the "statuses" edge to the Status entity.
func (m *RoundMutation) RemovedStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removedstatuses {
		ids = append(ids, id)
	}
	return
}

// StatusesIDs returns the "statuses" edge IDs in the mutation.
func (m *RoundMutation) StatusesIDs() (ids []uuid.UUID) {
	for id := range m.statuses {
		ids = append(ids, id)
	}
	return
}

// ResetStatuses resets all changes to the "statuses" edge.
func (m *RoundMutation) ResetStatuses() {
	m.statuses = nil
	m.clearedstatuses = false
	m.removedstatuses = nil
}

// AddScoreCachIDs adds the "scoreCaches" edge to the ScoreCache entity by ids.
func (m *RoundMutation) AddScoreCachIDs(ids ...uuid.UUID) {
	if m.scoreCaches == nil {
		m.scoreCaches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scoreCaches[ids[i]] = struct{}{}
	}
}

// ClearScoreCaches clears the "scoreCaches" edge to the ScoreCache entity.
func (m *RoundMutation) ClearScoreCaches() {
	m.clearedscoreCaches = true
}

// ScoreCachesCleared reports if the "scoreCaches" edge to the ScoreCache entity was cleared.
func (m *RoundMutation) ScoreCachesCleared() bool {
	return m.clearedscoreCaches
}

// RemoveScoreCachIDs removes the "scoreCaches" edge to the ScoreCache entity by IDs.
func (m *RoundMutation) RemoveScoreCachIDs(ids ...uuid.UUID) {
	if m.removedscoreCaches == nil {
		m.removedscoreCaches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scoreCaches, ids[i])
		m.removedscoreCaches[ids[i]] = struct{}{}
	}
}

// RemovedScoreCaches returns the removed IDs of the "scoreCaches" edge to the ScoreCache entity.
func (m *RoundMutation) RemovedScoreCachesIDs() (ids []uuid.UUID) {
	for id := range m.removedscoreCaches {
		ids = append(ids, id)
	}
	return
}

// ScoreCachesIDs returns the "scoreCaches" edge IDs in the mutation.
func (m *RoundMutation) ScoreCachesIDs() (ids []uuid.UUID) {
	for id := range m.scoreCaches {
		ids = append(ids, id)
	}
	return
}

// ResetScoreCaches resets all changes to the "scoreCaches" edge.
func (m *RoundMutation) ResetScoreCaches() {
	m.scoreCaches = nil
	m.clearedscoreCaches = false
	m.removedscoreCaches = nil
}

// Where appends a list predicates to the RoundMutation builder.
func (m *RoundMutation) Where(ps ...predicate.Round) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Round, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Round).
func (m *RoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, round.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, round.FieldUpdateTime)
	}
	if m.number != nil {
		fields = append(fields, round.FieldNumber)
	}
	if m.complete != nil {
		fields = append(fields, round.FieldComplete)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case round.FieldCreateTime:
		return m.CreateTime()
	case round.FieldUpdateTime:
		return m.UpdateTime()
	case round.FieldNumber:
		return m.Number()
	case round.FieldComplete:
		return m.Complete()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case round.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case round.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case round.FieldNumber:
		return m.OldNumber(ctx)
	case round.FieldComplete:
		return m.OldComplete(ctx)
	}
	return nil, fmt.Errorf("unknown Round field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case round.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case round.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case round.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case round.FieldComplete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplete(v)
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, round.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case round.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case round.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Round numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Round nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundMutation) ResetField(name string) error {
	switch name {
	case round.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case round.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case round.FieldNumber:
		m.ResetNumber()
		return nil
	case round.FieldComplete:
		m.ResetComplete()
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.statuses != nil {
		edges = append(edges, round.EdgeStatuses)
	}
	if m.scoreCaches != nil {
		edges = append(edges, round.EdgeScoreCaches)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.statuses))
		for id := range m.statuses {
			ids = append(ids, id)
		}
		return ids
	case round.EdgeScoreCaches:
		ids := make([]ent.Value, 0, len(m.scoreCaches))
		for id := range m.scoreCaches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstatuses != nil {
		edges = append(edges, round.EdgeStatuses)
	}
	if m.removedscoreCaches != nil {
		edges = append(edges, round.EdgeScoreCaches)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.removedstatuses))
		for id := range m.removedstatuses {
			ids = append(ids, id)
		}
		return ids
	case round.EdgeScoreCaches:
		ids := make([]ent.Value, 0, len(m.removedscoreCaches))
		for id := range m.removedscoreCaches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstatuses {
		edges = append(edges, round.EdgeStatuses)
	}
	if m.clearedscoreCaches {
		edges = append(edges, round.EdgeScoreCaches)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundMutation) EdgeCleared(name string) bool {
	switch name {
	case round.EdgeStatuses:
		return m.clearedstatuses
	case round.EdgeScoreCaches:
		return m.clearedscoreCaches
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Round unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundMutation) ResetEdge(name string) error {
	switch name {
	case round.EdgeStatuses:
		m.ResetStatuses()
		return nil
	case round.EdgeScoreCaches:
		m.ResetScoreCaches()
		return nil
	}
	return fmt.Errorf("unknown Round edge %s", name)
}

// ScoreCacheMutation represents an operation that mutates the ScoreCache nodes in the graph.
type ScoreCacheMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	points        *int
	addpoints     *int
	clearedFields map[string]struct{}
	round         *uuid.UUID
	clearedround  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*ScoreCache, error)
	predicates    []predicate.ScoreCache
}

var _ ent.Mutation = (*ScoreCacheMutation)(nil)

// scorecacheOption allows management of the mutation configuration using functional options.
type scorecacheOption func(*ScoreCacheMutation)

// newScoreCacheMutation creates new mutation for the ScoreCache entity.
func newScoreCacheMutation(c config, op Op, opts ...scorecacheOption) *ScoreCacheMutation {
	m := &ScoreCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeScoreCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScoreCacheID sets the ID field of the mutation.
func withScoreCacheID(id uuid.UUID) scorecacheOption {
	return func(m *ScoreCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *ScoreCache
		)
		m.oldValue = func(ctx context.Context) (*ScoreCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScoreCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScoreCache sets the old ScoreCache of the mutation.
func withScoreCache(node *ScoreCache) scorecacheOption {
	return func(m *ScoreCacheMutation) {
		m.oldValue = func(context.Context) (*ScoreCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScoreCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScoreCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScoreCache entities.
func (m *ScoreCacheMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScoreCacheMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScoreCacheMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScoreCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ScoreCacheMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScoreCacheMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScoreCache entity.
// If the ScoreCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreCacheMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScoreCacheMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ScoreCacheMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScoreCacheMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ScoreCache entity.
// If the ScoreCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreCacheMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScoreCacheMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPoints sets the "points" field.
func (m *ScoreCacheMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *ScoreCacheMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the ScoreCache entity.
// If the ScoreCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreCacheMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *ScoreCacheMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *ScoreCacheMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *ScoreCacheMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetRoundID sets the "round_id" field.
func (m *ScoreCacheMutation) SetRoundID(u uuid.UUID) {
	m.round = &u
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *ScoreCacheMutation) RoundID() (r uuid.UUID, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the ScoreCache entity.
// If the ScoreCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreCacheMutation) OldRoundID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *ScoreCacheMutation) ResetRoundID() {
	m.round = nil
}

// SetUserID sets the "user_id" field.
func (m *ScoreCacheMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ScoreCacheMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ScoreCache entity.
// If the ScoreCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScoreCacheMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ScoreCacheMutation) ResetUserID() {
	m.user = nil
}

// ClearRound clears the "round" edge to the Round entity.
func (m *ScoreCacheMutation) ClearRound() {
	m.clearedround = true
	m.clearedFields[scorecache.FieldRoundID] = struct{}{}
}

// RoundCleared reports if the "round" edge to the Round entity was cleared.
func (m *ScoreCacheMutation) RoundCleared() bool {
	return m.clearedround
}

// RoundIDs returns the "round" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundID instead. It exists only for internal usage by the builders.
func (m *ScoreCacheMutation) RoundIDs() (ids []uuid.UUID) {
	if id := m.round; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRound resets all changes to the "round" edge.
func (m *ScoreCacheMutation) ResetRound() {
	m.round = nil
	m.clearedround = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ScoreCacheMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[scorecache.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ScoreCacheMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ScoreCacheMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ScoreCacheMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ScoreCacheMutation builder.
func (m *ScoreCacheMutation) Where(ps ...predicate.ScoreCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScoreCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScoreCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScoreCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScoreCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScoreCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScoreCache).
func (m *ScoreCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScoreCacheMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, scorecache.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, scorecache.FieldUpdateTime)
	}
	if m.points != nil {
		fields = append(fields, scorecache.FieldPoints)
	}
	if m.round != nil {
		fields = append(fields, scorecache.FieldRoundID)
	}
	if m.user != nil {
		fields = append(fields, scorecache.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScoreCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scorecache.FieldCreateTime:
		return m.CreateTime()
	case scorecache.FieldUpdateTime:
		return m.UpdateTime()
	case scorecache.FieldPoints:
		return m.Points()
	case scorecache.FieldRoundID:
		return m.RoundID()
	case scorecache.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScoreCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scorecache.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case scorecache.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case scorecache.FieldPoints:
		return m.OldPoints(ctx)
	case scorecache.FieldRoundID:
		return m.OldRoundID(ctx)
	case scorecache.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown ScoreCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scorecache.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case scorecache.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case scorecache.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case scorecache.FieldRoundID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case scorecache.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ScoreCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScoreCacheMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, scorecache.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScoreCacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scorecache.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScoreCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scorecache.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown ScoreCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScoreCacheMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScoreCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScoreCacheMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ScoreCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScoreCacheMutation) ResetField(name string) error {
	switch name {
	case scorecache.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case scorecache.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case scorecache.FieldPoints:
		m.ResetPoints()
		return nil
	case scorecache.FieldRoundID:
		m.ResetRoundID()
		return nil
	case scorecache.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown ScoreCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScoreCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.round != nil {
		edges = append(edges, scorecache.EdgeRound)
	}
	if m.user != nil {
		edges = append(edges, scorecache.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScoreCacheMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scorecache.EdgeRound:
		if id := m.round; id != nil {
			return []ent.Value{*id}
		}
	case scorecache.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScoreCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScoreCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScoreCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedround {
		edges = append(edges, scorecache.EdgeRound)
	}
	if m.cleareduser {
		edges = append(edges, scorecache.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScoreCacheMutation) EdgeCleared(name string) bool {
	switch name {
	case scorecache.EdgeRound:
		return m.clearedround
	case scorecache.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScoreCacheMutation) ClearEdge(name string) error {
	switch name {
	case scorecache.EdgeRound:
		m.ClearRound()
		return nil
	case scorecache.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ScoreCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScoreCacheMutation) ResetEdge(name string) error {
	switch name {
	case scorecache.EdgeRound:
		m.ResetRound()
		return nil
	case scorecache.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ScoreCache edge %s", name)
}

// StatusMutation represents an operation that mutates the Status nodes in the graph.
type StatusMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	error         *string
	status        *status.Status
	points        *int
	addpoints     *int
	clearedFields map[string]struct{}
	check         *uuid.UUID
	clearedcheck  bool
	round         *uuid.UUID
	clearedround  bool
	user          *uuid.UUID
	cleareduser   bool
	minion        *uuid.UUID
	clearedminion bool
	done          bool
	oldValue      func(context.Context) (*Status, error)
	predicates    []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows management of the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for the Status entity.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the ID field of the mutation.
func withStatusID(id uuid.UUID) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Status entities.
func (m *StatusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Status.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StatusMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatusMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatusMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StatusMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StatusMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StatusMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetError sets the "error" field.
func (m *StatusMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *StatusMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *StatusMutation) ClearError() {
	m.error = nil
	m.clearedFields[status.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *StatusMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[status.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *StatusMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, status.FieldError)
}

// SetStatus sets the "status" field.
func (m *StatusMutation) SetStatus(s status.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StatusMutation) Status() (r status.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldStatus(ctx context.Context) (v status.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StatusMutation) ResetStatus() {
	m.status = nil
}

// SetPoints sets the "points" field.
func (m *StatusMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *StatusMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *StatusMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *StatusMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *StatusMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetCheckID sets the "check_id" field.
func (m *StatusMutation) SetCheckID(u uuid.UUID) {
	m.check = &u
}

// CheckID returns the value of the "check_id" field in the mutation.
func (m *StatusMutation) CheckID() (r uuid.UUID, exists bool) {
	v := m.check
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckID returns the old "check_id" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldCheckID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckID: %w", err)
	}
	return oldValue.CheckID, nil
}

// ResetCheckID resets all changes to the "check_id" field.
func (m *StatusMutation) ResetCheckID() {
	m.check = nil
}

// SetRoundID sets the "round_id" field.
func (m *StatusMutation) SetRoundID(u uuid.UUID) {
	m.round = &u
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *StatusMutation) RoundID() (r uuid.UUID, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldRoundID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *StatusMutation) ResetRoundID() {
	m.round = nil
}

// SetUserID sets the "user_id" field.
func (m *StatusMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StatusMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StatusMutation) ResetUserID() {
	m.user = nil
}

// SetMinionID sets the "minion_id" field.
func (m *StatusMutation) SetMinionID(u uuid.UUID) {
	m.minion = &u
}

// MinionID returns the value of the "minion_id" field in the mutation.
func (m *StatusMutation) MinionID() (r uuid.UUID, exists bool) {
	v := m.minion
	if v == nil {
		return
	}
	return *v, true
}

// OldMinionID returns the old "minion_id" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldMinionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinionID: %w", err)
	}
	return oldValue.MinionID, nil
}

// ClearMinionID clears the value of the "minion_id" field.
func (m *StatusMutation) ClearMinionID() {
	m.minion = nil
	m.clearedFields[status.FieldMinionID] = struct{}{}
}

// MinionIDCleared returns if the "minion_id" field was cleared in this mutation.
func (m *StatusMutation) MinionIDCleared() bool {
	_, ok := m.clearedFields[status.FieldMinionID]
	return ok
}

// ResetMinionID resets all changes to the "minion_id" field.
func (m *StatusMutation) ResetMinionID() {
	m.minion = nil
	delete(m.clearedFields, status.FieldMinionID)
}

// ClearCheck clears the "check" edge to the Check entity.
func (m *StatusMutation) ClearCheck() {
	m.clearedcheck = true
	m.clearedFields[status.FieldCheckID] = struct{}{}
}

// CheckCleared reports if the "check" edge to the Check entity was cleared.
func (m *StatusMutation) CheckCleared() bool {
	return m.clearedcheck
}

// CheckIDs returns the "check" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CheckID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) CheckIDs() (ids []uuid.UUID) {
	if id := m.check; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheck resets all changes to the "check" edge.
func (m *StatusMutation) ResetCheck() {
	m.check = nil
	m.clearedcheck = false
}

// ClearRound clears the "round" edge to the Round entity.
func (m *StatusMutation) ClearRound() {
	m.clearedround = true
	m.clearedFields[status.FieldRoundID] = struct{}{}
}

// RoundCleared reports if the "round" edge to the Round entity was cleared.
func (m *StatusMutation) RoundCleared() bool {
	return m.clearedround
}

// RoundIDs returns the "round" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) RoundIDs() (ids []uuid.UUID) {
	if id := m.round; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRound resets all changes to the "round" edge.
func (m *StatusMutation) ResetRound() {
	m.round = nil
	m.clearedround = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *StatusMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[status.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StatusMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StatusMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearMinion clears the "minion" edge to the Minion entity.
func (m *StatusMutation) ClearMinion() {
	m.clearedminion = true
	m.clearedFields[status.FieldMinionID] = struct{}{}
}

// MinionCleared reports if the "minion" edge to the Minion entity was cleared.
func (m *StatusMutation) MinionCleared() bool {
	return m.MinionIDCleared() || m.clearedminion
}

// MinionIDs returns the "minion" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MinionID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) MinionIDs() (ids []uuid.UUID) {
	if id := m.minion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMinion resets all changes to the "minion" edge.
func (m *StatusMutation) ResetMinion() {
	m.minion = nil
	m.clearedminion = false
}

// Where appends a list predicates to the StatusMutation builder.
func (m *StatusMutation) Where(ps ...predicate.Status) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Status, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, status.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, status.FieldUpdateTime)
	}
	if m.error != nil {
		fields = append(fields, status.FieldError)
	}
	if m.status != nil {
		fields = append(fields, status.FieldStatus)
	}
	if m.points != nil {
		fields = append(fields, status.FieldPoints)
	}
	if m.check != nil {
		fields = append(fields, status.FieldCheckID)
	}
	if m.round != nil {
		fields = append(fields, status.FieldRoundID)
	}
	if m.user != nil {
		fields = append(fields, status.FieldUserID)
	}
	if m.minion != nil {
		fields = append(fields, status.FieldMinionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldCreateTime:
		return m.CreateTime()
	case status.FieldUpdateTime:
		return m.UpdateTime()
	case status.FieldError:
		return m.Error()
	case status.FieldStatus:
		return m.Status()
	case status.FieldPoints:
		return m.Points()
	case status.FieldCheckID:
		return m.CheckID()
	case status.FieldRoundID:
		return m.RoundID()
	case status.FieldUserID:
		return m.UserID()
	case status.FieldMinionID:
		return m.MinionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case status.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case status.FieldError:
		return m.OldError(ctx)
	case status.FieldStatus:
		return m.OldStatus(ctx)
	case status.FieldPoints:
		return m.OldPoints(ctx)
	case status.FieldCheckID:
		return m.OldCheckID(ctx)
	case status.FieldRoundID:
		return m.OldRoundID(ctx)
	case status.FieldUserID:
		return m.OldUserID(ctx)
	case status.FieldMinionID:
		return m.OldMinionID(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case status.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case status.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case status.FieldStatus:
		v, ok := value.(status.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case status.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case status.FieldCheckID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckID(v)
		return nil
	case status.FieldRoundID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case status.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case status.FieldMinionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinionID(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, status.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case status.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case status.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(status.FieldError) {
		fields = append(fields, status.FieldError)
	}
	if m.FieldCleared(status.FieldMinionID) {
		fields = append(fields, status.FieldMinionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	switch name {
	case status.FieldError:
		m.ClearError()
		return nil
	case status.FieldMinionID:
		m.ClearMinionID()
		return nil
	}
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case status.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case status.FieldError:
		m.ResetError()
		return nil
	case status.FieldStatus:
		m.ResetStatus()
		return nil
	case status.FieldPoints:
		m.ResetPoints()
		return nil
	case status.FieldCheckID:
		m.ResetCheckID()
		return nil
	case status.FieldRoundID:
		m.ResetRoundID()
		return nil
	case status.FieldUserID:
		m.ResetUserID()
		return nil
	case status.FieldMinionID:
		m.ResetMinionID()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.check != nil {
		edges = append(edges, status.EdgeCheck)
	}
	if m.round != nil {
		edges = append(edges, status.EdgeRound)
	}
	if m.user != nil {
		edges = append(edges, status.EdgeUser)
	}
	if m.minion != nil {
		edges = append(edges, status.EdgeMinion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeCheck:
		if id := m.check; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeRound:
		if id := m.round; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeMinion:
		if id := m.minion; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcheck {
		edges = append(edges, status.EdgeCheck)
	}
	if m.clearedround {
		edges = append(edges, status.EdgeRound)
	}
	if m.cleareduser {
		edges = append(edges, status.EdgeUser)
	}
	if m.clearedminion {
		edges = append(edges, status.EdgeMinion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	case status.EdgeCheck:
		return m.clearedcheck
	case status.EdgeRound:
		return m.clearedround
	case status.EdgeUser:
		return m.cleareduser
	case status.EdgeMinion:
		return m.clearedminion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	case status.EdgeCheck:
		m.ClearCheck()
		return nil
	case status.EdgeRound:
		m.ClearRound()
		return nil
	case status.EdgeUser:
		m.ClearUser()
		return nil
	case status.EdgeMinion:
		m.ClearMinion()
		return nil
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeCheck:
		m.ResetCheck()
		return nil
	case status.EdgeRound:
		m.ResetRound()
		return nil
	case status.EdgeUser:
		m.ResetUser()
		return nil
	case status.EdgeMinion:
		m.ResetMinion()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	username           *string
	password           *string
	role               *user.Role
	number             *int
	addnumber          *int
	clearedFields      map[string]struct{}
	configs            map[uuid.UUID]struct{}
	removedconfigs     map[uuid.UUID]struct{}
	clearedconfigs     bool
	statuses           map[uuid.UUID]struct{}
	removedstatuses    map[uuid.UUID]struct{}
	clearedstatuses    bool
	scoreCaches        map[uuid.UUID]struct{}
	removedscoreCaches map[uuid.UUID]struct{}
	clearedscoreCaches bool
	submissions        map[uuid.UUID]struct{}
	removedsubmissions map[uuid.UUID]struct{}
	clearedsubmissions bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetNumber sets the "number" field.
func (m *UserMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *UserMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *UserMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *UserMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *UserMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[user.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *UserMutation) NumberCleared() bool {
	_, ok := m.clearedFields[user.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *UserMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, user.FieldNumber)
}

// AddConfigIDs adds the "configs" edge to the CheckConfig entity by ids.
func (m *UserMutation) AddConfigIDs(ids ...uuid.UUID) {
	if m.configs == nil {
		m.configs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.configs[ids[i]] = struct{}{}
	}
}

// ClearConfigs clears the "configs" edge to the CheckConfig entity.
func (m *UserMutation) ClearConfigs() {
	m.clearedconfigs = true
}

// ConfigsCleared reports if the "configs" edge to the CheckConfig entity was cleared.
func (m *UserMutation) ConfigsCleared() bool {
	return m.clearedconfigs
}

// RemoveConfigIDs removes the "configs" edge to the CheckConfig entity by IDs.
func (m *UserMutation) RemoveConfigIDs(ids ...uuid.UUID) {
	if m.removedconfigs == nil {
		m.removedconfigs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.configs, ids[i])
		m.removedconfigs[ids[i]] = struct{}{}
	}
}

// RemovedConfigs returns the removed IDs of the "configs" edge to the CheckConfig entity.
func (m *UserMutation) RemovedConfigsIDs() (ids []uuid.UUID) {
	for id := range m.removedconfigs {
		ids = append(ids, id)
	}
	return
}

// ConfigsIDs returns the "configs" edge IDs in the mutation.
func (m *UserMutation) ConfigsIDs() (ids []uuid.UUID) {
	for id := range m.configs {
		ids = append(ids, id)
	}
	return
}

// ResetConfigs resets all changes to the "configs" edge.
func (m *UserMutation) ResetConfigs() {
	m.configs = nil
	m.clearedconfigs = false
	m.removedconfigs = nil
}

// AddStatusIDs adds the "statuses" edge to the Status entity by ids.
func (m *UserMutation) AddStatusIDs(ids ...uuid.UUID) {
	if m.statuses == nil {
		m.statuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.statuses[ids[i]] = struct{}{}
	}
}

// ClearStatuses clears the "statuses" edge to the Status entity.
func (m *UserMutation) ClearStatuses() {
	m.clearedstatuses = true
}

// StatusesCleared reports if the "statuses" edge to the Status entity was cleared.
func (m *UserMutation) StatusesCleared() bool {
	return m.clearedstatuses
}

// RemoveStatusIDs removes the "statuses" edge to the Status entity by IDs.
func (m *UserMutation) RemoveStatusIDs(ids ...uuid.UUID) {
	if m.removedstatuses == nil {
		m.removedstatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.statuses, ids[i])
		m.removedstatuses[ids[i]] = struct{}{}
	}
}

// RemovedStatuses returns the removed IDs of the "statuses" edge to the Status entity.
func (m *UserMutation) RemovedStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removedstatuses {
		ids = append(ids, id)
	}
	return
}

// StatusesIDs returns the "statuses" edge IDs in the mutation.
func (m *UserMutation) StatusesIDs() (ids []uuid.UUID) {
	for id := range m.statuses {
		ids = append(ids, id)
	}
	return
}

// ResetStatuses resets all changes to the "statuses" edge.
func (m *UserMutation) ResetStatuses() {
	m.statuses = nil
	m.clearedstatuses = false
	m.removedstatuses = nil
}

// AddScoreCachIDs adds the "scoreCaches" edge to the ScoreCache entity by ids.
func (m *UserMutation) AddScoreCachIDs(ids ...uuid.UUID) {
	if m.scoreCaches == nil {
		m.scoreCaches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scoreCaches[ids[i]] = struct{}{}
	}
}

// ClearScoreCaches clears the "scoreCaches" edge to the ScoreCache entity.
func (m *UserMutation) ClearScoreCaches() {
	m.clearedscoreCaches = true
}

// ScoreCachesCleared reports if the "scoreCaches" edge to the ScoreCache entity was cleared.
func (m *UserMutation) ScoreCachesCleared() bool {
	return m.clearedscoreCaches
}

// RemoveScoreCachIDs removes the "scoreCaches" edge to the ScoreCache entity by IDs.
func (m *UserMutation) RemoveScoreCachIDs(ids ...uuid.UUID) {
	if m.removedscoreCaches == nil {
		m.removedscoreCaches = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scoreCaches, ids[i])
		m.removedscoreCaches[ids[i]] = struct{}{}
	}
}

// RemovedScoreCaches returns the removed IDs of the "scoreCaches" edge to the ScoreCache entity.
func (m *UserMutation) RemovedScoreCachesIDs() (ids []uuid.UUID) {
	for id := range m.removedscoreCaches {
		ids = append(ids, id)
	}
	return
}

// ScoreCachesIDs returns the "scoreCaches" edge IDs in the mutation.
func (m *UserMutation) ScoreCachesIDs() (ids []uuid.UUID) {
	for id := range m.scoreCaches {
		ids = append(ids, id)
	}
	return
}

// ResetScoreCaches resets all changes to the "scoreCaches" edge.
func (m *UserMutation) ResetScoreCaches() {
	m.scoreCaches = nil
	m.clearedscoreCaches = false
	m.removedscoreCaches = nil
}

// AddSubmissionIDs adds the "submissions" edge to the InjectSubmission entity by ids.
func (m *UserMutation) AddSubmissionIDs(ids ...uuid.UUID) {
	if m.submissions == nil {
		m.submissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the InjectSubmission entity.
func (m *UserMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the InjectSubmission entity was cleared.
func (m *UserMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the InjectSubmission entity by IDs.
func (m *UserMutation) RemoveSubmissionIDs(ids ...uuid.UUID) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the InjectSubmission entity.
func (m *UserMutation) RemovedSubmissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *UserMutation) SubmissionsIDs() (ids []uuid.UUID) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *UserMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.number != nil {
		fields = append(fields, user.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	case user.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, user.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldNumber) {
		fields = append(fields, user.FieldNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldNumber:
		m.ClearNumber()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.configs != nil {
		edges = append(edges, user.EdgeConfigs)
	}
	if m.statuses != nil {
		edges = append(edges, user.EdgeStatuses)
	}
	if m.scoreCaches != nil {
		edges = append(edges, user.EdgeScoreCaches)
	}
	if m.submissions != nil {
		edges = append(edges, user.EdgeSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeConfigs:
		ids := make([]ent.Value, 0, len(m.configs))
		for id := range m.configs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.statuses))
		for id := range m.statuses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeScoreCaches:
		ids := make([]ent.Value, 0, len(m.scoreCaches))
		for id := range m.scoreCaches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedconfigs != nil {
		edges = append(edges, user.EdgeConfigs)
	}
	if m.removedstatuses != nil {
		edges = append(edges, user.EdgeStatuses)
	}
	if m.removedscoreCaches != nil {
		edges = append(edges, user.EdgeScoreCaches)
	}
	if m.removedsubmissions != nil {
		edges = append(edges, user.EdgeSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeConfigs:
		ids := make([]ent.Value, 0, len(m.removedconfigs))
		for id := range m.removedconfigs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStatuses:
		ids := make([]ent.Value, 0, len(m.removedstatuses))
		for id := range m.removedstatuses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeScoreCaches:
		ids := make([]ent.Value, 0, len(m.removedscoreCaches))
		for id := range m.removedscoreCaches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedconfigs {
		edges = append(edges, user.EdgeConfigs)
	}
	if m.clearedstatuses {
		edges = append(edges, user.EdgeStatuses)
	}
	if m.clearedscoreCaches {
		edges = append(edges, user.EdgeScoreCaches)
	}
	if m.clearedsubmissions {
		edges = append(edges, user.EdgeSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeConfigs:
		return m.clearedconfigs
	case user.EdgeStatuses:
		return m.clearedstatuses
	case user.EdgeScoreCaches:
		return m.clearedscoreCaches
	case user.EdgeSubmissions:
		return m.clearedsubmissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeConfigs:
		m.ResetConfigs()
		return nil
	case user.EdgeStatuses:
		m.ResetStatuses()
		return nil
	case user.EdgeScoreCaches:
		m.ResetScoreCaches()
		return nil
	case user.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
